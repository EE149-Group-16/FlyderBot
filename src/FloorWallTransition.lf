target C {
    platform: "RP2040",
    // files: ["../../robot-lib"],
    // cmake-include: ["../../robot-lib/robot-lib.txt"],
    single-threaded: true
}

import Propeller from "lib/Propeller.lf"
import Servos from "lib/Servos.lf"
import mpu from "lib/mpu6050.lf"
import Ultrasonic from "lib/Ultrasonic.lf"

main reactor {
    propeller = new Propeller()
    servos = new Servos()
    mpu = new mpu()
    u = new Ultrasonic()
    timer t(12 s, 3 s)
    timer ptimer(0 s, 1 s);
    timer t_mpu(1 s, 50 ms) 
    timer stop(60 s)
    timer startPropeller(12 s, 200 ms)
    timer t_u1(3000 ms, 200 ms)
    timer t_u2(3100 ms, 200 ms)
    // timer stopPropeller(20 s)

    state frontPower: uint16_t

    state rearPower: uint16_t
    state rearAngle: uint16_t
    state frontAngle: uint16_t

    state rising: bool
    state done: bool
    
    state mpu_pitch: float

    state last_roll: float
    reaction (startup) -> servos.front_angle, servos.rear_angle {=
        self -> frontPower = 1000; // started at 1350 power
        self -> rearPower = 1300;
        self -> rearAngle = 65;
        self -> frontAngle = 120;
        lf_set(servos.rear_angle, self->rearAngle);
        lf_set(servos.front_angle, self->frontAngle);
        
        self-> rising = true;
        self-> done = false;
    =}

    reaction(t_u1) -> u.trigger_l  {=
        lf_set(u.trigger_l, true);
    =}

    reaction(t_u2) -> u.trigger_r {=
        lf_set(u.trigger_r, true);
    =}


    reaction(t_mpu) -> mpu.trigger{= //pulsing imu
        lf_set(mpu.trigger, true);
    =}
    
    // reaction(t_mpu) {= //ermegency stop if we got too fast
    //     if (self->frontPower >= 1400 || self->rearPower >= 1700) {
    //         self->frontPower =1000 ;
    //         self->rearPower = 1300;
    //     }
    // =}
    

    reaction(startPropeller) -> propeller.front_power, propeller.rear_power {=
        if (self->frontPower >= 1400 || self->rearPower >= 1700) {
            self->frontPower =1000 ;
            self->rearPower = 1300;
        }
        lf_set(propeller.front_power, self->frontPower);
        lf_set(propeller.rear_power, self->rearPower);
        printf("Setting Prop Front power: %d, back power: %d\n", self->frontPower,self->rearPower);
    =}

    reaction(mpu.pitch) {= //updating our state variable for roll
        self->mpu_pitch = mpu.pitch->value;
        //printf("imu roll: %f\n", self->mpu_pitch);

    =}

    initial mode {
        reaction(startPropeller) -> reset(FLOOR) {=
            lf_set_mode(FLOOR);
        =}
            reaction(ptimer) {=
                    printf("In init mode\n");
                    printf("mode react front power: %d, back power: %d\n", self->frontPower,self->rearPower);
        
                =}
    } 
    
    
    mode FLOOR {
        reaction(ptimer) {=
            printf("In floor mode\n");
            printf("mode react front power: %d, back power: %d\n", self->frontPower,self->rearPower);

        =}
        reaction(t_mpu) -> servos.front_angle, servos.rear_angle{= //takes care of the angles       
            lf_set(servos.front_angle, 65);
            lf_set(servos.rear_angle, 120);
        =}
        // reaction(t_mpu) {= //takes care of the motors 
        //     self->frontPower = 1050;
        //     self->rearPower = 1350;
            
        //     self->last_roll = self->mpu_pitch;
        // =}
        reaction(u.left) -> reset(FLOOR_WALL) {=
            if (u.left->value < 0) {
                
            } else if (u.left->value <= 7) {
                lf_set_mode(FLOOR_WALL);
                self->frontPower = 1000;
                self->rearPower = 1300;
            }
            else if (u.left->value <= 20) {
                self->frontPower = 1020;
                self->rearPower = 1320;
            } else {
                self->frontPower = 1030;
                self->rearPower = 1330;
            }
            printf("Front power: %d, back power: %d\n", self->frontPower,self->rearPower);
            //printf("distance: %f\n", u.left->value);
            self->last_roll = self->mpu_pitch;
            
        =}

        // reaction(u.right) {=
        //     printf("right: %2.4f\n", u.right->value);
        // =}
    }

    mode FLOOR_WALL {
        reaction(u.left) {=
            // printf("distance: %f\n", u.left->value);
            // printf("mpu pitch: %f\n", self->mpu_pitch);
        =}
        reaction(t_mpu) -> servos.front_angle, servos.rear_angle{= //takes care of the angles 
            int front = 160 + self->mpu_pitch;
            int back =90 - self->mpu_pitch;
           
      
           
            lf_set(servos.front_angle, front);
            lf_set(servos.rear_angle, back);
        =}

        reaction(t_mpu) {= //takes care of the motors 
            // if (self->last_roll - self->mpu_pitch < 20){
            //     self->frontPower += 50;
            //     self->rearPower += 50;
            // }
            self->last_roll = self->mpu_pitch;
        =}

        // reaction(t_mpu) -> reset(DONE){=
        //     if (self->mpu_pitch < -80) {
        //         lf_set_mode(DONE);
        //     }
        // =}

}

    
    mode DONE {
        // reaction(t_mpu) -> servos.front_angle, servos.rear_angle {=
        //     lf_set(servos.front_angle, front);
        //     lf_set(servos.rear_angle, back);
        // =}
    }
    

    
    // reaction(startPropeller) {=
    //     lf_set(propeller.rear_power, 1500);
    // =}
    // reaction(stopPropeller) {=
    //     lf_set(propeller.rear_power, 1000);
    // =}
    // reaction(t) -> servos.rear_angle, servos.front_angle {=
    //     lf_set(servos.rear_angle, self->rearAngle);
    //     lf_set(servos.front_angle, self->frontAngle);
    //     // self->rearAngle -= 10;
    // =}

// NOTES
// 1250 strong enough to push against wall but not to prop (even at 90 deg)
}